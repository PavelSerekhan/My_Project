package Extends_Extends_Насделование;
/**
 * Чтобы объявить один класс наследником другого, надо после имени класса написать слово extends,
 * после которого идёт имя базового класса. Класс Employee наследует все те же поля и методы,
 * которые есть у Person. Если в базовом классе определены конструкторы, то в конструкторе
 * производного класса необходимо вызвать один из конструкторов базового класса с помощью
 * ключевого слова super.
 * extends - расширяет
 */
public class Employee extends Person {
    /**
     * Производный класс также может добавлять свои поля и методы.
     * Мы можем наследовать только от одного класса!!!!
     */
    String company;

    // если базовый класс определяет конструктор, то произвольный класс
    // должен его вызвать

    public Employee(String name, String company) {
        super(name);
        this.company = company;
    }

    public void work() { // свой метод в Employee
        System.out.printf("%s work in %s \n", getName(), company);
    }

    /**
     * Производный класс может определять свои методы, а может переопределять методы,
     * которые унаследованы от базового класса.
     *
     * Запретить наследование с помощью ключевого слова final.(public final class Person)
     * или методы (public final void display()).
     */
    @Override
    public void display() {
        //System.out.printf("Name: %s \n",getName());
        // Однако в данном случае мы видим,
        // что часть метода display в Employee повторяет действия из метода display базового
        // класса. Поэтому мы можем сократить класс Employee:
        //С помощью ключевого слова super мы также можем обратиться к реализации методов базового класса.
        super.display();
        System.out.printf("Work in %s \n", company);
    }

    /**
     * Динамическая диспетчеризация методов
     * Однако несмотря на то, что переменная представляет объект Person, виртуальная машина видит,
     * что в реальности она указывает на объект Employee. Поэтому при вызове методов у этого
     * объекта будет вызываться та версия метода, которая определена в классе Employee, а не в
     * Person.  Person sam = new Employee("Sam", "Oracle");
     */
}
